<!--Matt Hay ~ Web ~ 11/16/21-->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- Bootstrap CSS -->
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
        <script src="{{url_for('static', filename='gameScreen.js')}}"></script>
        <script src="https://unpkg.com/konva@8.3.0/konva.min.js"></script>
        <!--<title> In-Game: {{game.name}} </title>-->
    </head>
    <header>
        <nav class="navbar navbar-expand-sm navbar-light bg-light">
          <div class="container-fluid">
            <a class="navbar-brand" style="font-weight:bold"> Game: {{game.name}} </a>
          </div>
          <div class="d-flex">
            <a href="{{url_for('home')}}">
            <button style="" class="btn btn-outline-success my-2 my-sm-0" type="submit"> Home </button>
            </a>
            <a href="{{url_for('viewCharacters')}}">
            <button style="" class="btn btn-outline-success my-2 my-sm-0 mx-2" type="submit"> Characters </button>
            </a>
          </div>
        </nav>

        <div id="username" class="{{user}}" style="display:none;">
      </header>
    <body>
        <div class="d-flex w-100">
        <div id="Sidebar" class="w-25 border">
          <!--Sidebar header-->
          <div class="d-flex align-items-center flex-shrink-0 p-3 link-dark text-decoration-none border-bottom">
            <span class="fs-5 fw-semibold"> Live Game Feed </span>
          </div>
          <!--LIST DIV-->
          <div id="msg-feed" class="panel-body border m-2 scrollarea" 
            style="overflow-y: scroll !important; height:250px !important; overflow-x: hidden;">
              <!--LIST ITEMS GO HERE-->
              <div class="left clearfix border-bottom my-1" style="">
                <p class="mx-2" style="color:MediumSeaGreen; word-break: break-all;"> Your Adventure Awaits! </p>
              </div>
          </div>

          <div class="input-actions">
            <form role="form">
              <div class="form-group m-2">
                <textarea id="msg-box" class="form-control " style="resize:none; height:45px;" 
                  placeholder="Enter message..."></textarea>
              </div>
              <div class="form-group m-2">
                <button id="sendMsg-btn" type="button" class="btn border"> Send </button>
              </div>
            </form>

            <button id="roll-D6" style="" class="btn btn-outline-success m-2" > Roll D6 </button>
            <button id="roll-D10" style="" class="btn btn-outline-success m-2" > Roll D10 </button>
            <button id="roll-D20" style="" class="btn btn-outline-success m-2" > Roll D20 </button>
          </div>
        </div>

        <!-- Game Board -->
        <div id="GameBoard" class="w-75 border">
        </div>
        </div>
        <script>
      // define several math function
      function getCorner(pivotX, pivotY, diffX, diffY, angle) {
        const distance = Math.sqrt(diffX * diffX + diffY * diffY);

        /// find angle from pivot to corner
        angle += Math.atan2(diffY, diffX);

        /// get new x and y and round it off to integer
        const x = pivotX + distance * Math.cos(angle);
        const y = pivotY + distance * Math.sin(angle);

        return { x: x, y: y };
      }
      function getClientRect(rotatedBox) {
        const { x, y, width, height } = rotatedBox;
        const rad = rotatedBox.rotation;

        const p1 = getCorner(x, y, 0, 0, rad);
        const p2 = getCorner(x, y, width, 0, rad);
        const p3 = getCorner(x, y, width, height, rad);
        const p4 = getCorner(x, y, 0, height, rad);

        const minX = Math.min(p1.x, p2.x, p3.x, p4.x);
        const minY = Math.min(p1.y, p2.y, p3.y, p4.y);
        const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
        const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
        };
      }

      function getTotalBox(boxes) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        boxes.forEach((box) => {
          minX = Math.min(minX, box.x);
          minY = Math.min(minY, box.y);
          maxX = Math.max(maxX, box.x + box.width);
          maxY = Math.max(maxY, box.y + box.height);
        });
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
        };
      }

      var imageObj = new Image();
      imageObj.src = '/static/battle_map.jpg'
      console.log("async");

      let board = document.getElementById('GameBoard')
      const stage = new Konva.Stage({
        container: 'GameBoard',
        width: imageObj.naturalWidth,
        height: imageObj.naturalHeight,
      });

      const layer = new Konva.Layer();
      stage.add(layer);

      const background = new Konva.Rect({
        x: 0,
        y: 0,
        width: imageObj.naturalWidth,
        height: imageObj.naturalHeight,
        fillPatternImage: imageObj,
        draggable: false
      });
      layer.add(background);
      

      const shape1 = new Konva.Rect({
        x: stage.width() / 2 - 60,
        y: stage.height() / 2 - 60,
        width: 50,
        height: 50,
        fill: 'red',
        draggable: true,
      });
      layer.add(shape1);

      const tr = new Konva.Transformer({
        boundBoxFunc: (oldBox, newBox) => {
          const box = getClientRect(newBox);
          const isOut =
            box.x < 0 ||
            box.y < 0 ||
            box.x + box.width > stage.width() ||
            box.y + box.height > stage.height();

          // if new bounding box is out of visible viewport, let's just skip transforming
          // this logic can be improved by still allow some transforming if we have small available space
          if (isOut) {
            return oldBox;
          }
          return newBox;
        },
      });
      layer.add(tr);

      shape1.on('dragmove', () =>{
          const absPos = shape1.getAbsolutePosition();
          // where are shapes inside bounding box of all shapes?
          const offsetX = shape1.x - absPos.x;
          const offsetY = shape1.y - absPos.y;

          // we total box goes outside of viewport, we need to move absolute position of shape
          const newAbsPos = { ...absPos };
          if (shape1.x < 0) {
            newAbsPos.x = -offsetX;
          }
          if (shape1.y < 0) {
            newAbsPos.y = -offsetY;
          }
          if (shape1.x + shape1.width > stage.width()) {
            newAbsPos.x = stage.width() - shape1.width - offsetX;
          }
          if (shape1.y + shape1.height > stage.height()) {
            newAbsPos.y = stage.height() - shape1.height - offsetY;
          }
          shape1.setAbsolutePosition(newAbsPos);
      });

      // we can use transformer event
      // or just shape event
      tr.on('dragmove', () => {
        const boxes = tr.nodes().map((node) => node.getClientRect());
        const box = getTotalBox(boxes);
        tr.nodes().forEach((shape) => {
          const absPos = shape.getAbsolutePosition();
          // where are shapes inside bounding box of all shapes?
          const offsetX = box.x - absPos.x;
          const offsetY = box.y - absPos.y;

          // we total box goes outside of viewport, we need to move absolute position of shape
          const newAbsPos = { ...absPos };
          if (box.x < 0) {
            newAbsPos.x = -offsetX;
          }
          if (box.y < 0) {
            newAbsPos.y = -offsetY;
          }
          if (box.x + box.width > stage.width()) {
            newAbsPos.x = stage.width() - box.width - offsetX;
          }
          if (box.y + box.height > stage.height()) {
            newAbsPos.y = stage.height() - box.height - offsetY;
          }
          shape.setAbsolutePosition(newAbsPos);
        });
      });

      stage.on('click tap', function (e){
        if (e.target === stage){
          tr.nodes([]);
        }
        if (e.target === shape1) {
          tr.nodes([shape1])
        }
        if (e.target === background) {
          tr.nodes([])
        }
      });
    </script>
        
    </body>
</html>